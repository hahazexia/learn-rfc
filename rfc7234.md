# rfc7234

## 在缓存中存储响应

缓存不能存储任何请求的响应，除非（也就是说想要缓存，就必须达到以下条件）：

* 缓存能够`理解`请求方法，并且这个请求被定义为可缓存的
* 缓存能够`理解`响应的状态码
* `no-store` 缓存指令**不能**出现在请求或者响应头的字段中
* 如果缓存是共享的，`private` 响应指令**不能**出现在响应中
* 如果缓存是共享的，请求头中**不能**出现 `Authorization` 字段，除非响应明确允许了
* 响应满足下面任何一个：
    * 响应头包含了一个 `Expires` 字段
    * 包含了 `max-age` 响应指令
    * 包含了 `s-maxage` 响应指令 并且 缓存是共享的。
    * 包含了 `Cache-Control` 扩展来允许响应是可缓存的
    * 拥有一个默认被定义为可缓存的状态码
    * 或者包含 `public` 响应指令

注意，上面列出的任何要求都可以由 `Cache-Control` 覆盖掉。

在这个语境下，如果缓存可以识别和实现所有指定的与缓存相关的行为，那么就可以说缓存`理解`了这个请求方法或者响应状态码。

注意，在正常操作下，一些缓存不会存储 既没有缓存验证器也没有明确的到期时间 的响应，因为这样的响应通常没什么用。但是，缓存并不会禁止存储此类响应。

### 存储不完整的响应

当所有通过消息帧表示的8位字节在连接关闭之前被全部接收，这时才能说一条响应是完整的。如果是 GET 请求，响应状态码是 200，并且整个响应头被接收到，如果缓存条目被记录为不完整的话，缓存可能就会存储不完整的响应消息正文（body）。同样地，206状态码（Partial Content，服务器已经成功处理了部分 GET 请求，利用 Range 和 if-Range 请求头实现断点续传的时候就会出现这样的状态码）的响应也可能会被存储，如果它是一个不完整的 200 缓存条目的话。但是，如果响应不支持 `Range` 或 `Content-Range` 头部字段或者它不能识别在这些字段中的范围单位，那么缓存就**不能**存储不完整的或部分内容（Partial Content）的响应。

缓存可以通过这种方式完成一个存储的不完整响应：通过创建后续范围请求并且将范围请求的响应和之前的存储条目合并。缓存**不能**使用不完整响应去答复请求，除非这个不完整响应已经变得完整了，或者这个请求只请求部分内容并且指定的请求范围刚好就在不完整响应之中。如果没有明确使用 206 状态码，那么缓存**不能**向客户端发送部分的响应。

### 存储已授权请求的响应

